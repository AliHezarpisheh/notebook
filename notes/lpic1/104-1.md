# Create Partitions and Filesystems

## Block Devices

Block devices are the foundation of storage in Linux. They are non-volatile any piece of
hardware that stores data in fixed-size blocks and allows random access to those blocks.
By saying `fixed-size blocks`, we mean that the data are stored in fixed-size chunks and
can only be accessed if the whole chunk is read and accessed. For example if you want to
read a specific byte on the disk, the kernel should load the chunk containing it all at
once. By saying `random access`, we mean that you can jump to any block on the disk
without having to read all the blocks before it. HDD, SSD, USB sticks, and even loop
devices are all block devices.

```bash
ls -l /dev/ | grep "^b"
brw-rw----   1 root disk        7,     0 Dec 26 09:36 loop0
brw-rw----   1 root disk        7,     1 Dec 26 09:36 loop1
brw-rw----   1 root disk      259,     0 Dec 26 09:36 nvme0n1
brw-rw----   1 root disk      259,     1 Dec 26 09:36 nvme0n1p1
brw-rw----   1 root disk      259,     2 Dec 26 09:36 nvme0n1p2

lsblk
NAME        MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTS
loop0         7:0    0     4K  1 loop /snap/bare/5
loop1         7:1    0  55.5M  1 loop /snap/core18/2976
nvme0n1     259:0    0 476.9G  0 disk
├─nvme0n1p1 259:1    0   512M  0 part /boot/efi
└─nvme0n1p2 259:2    0 476.4G  0 part /

lsblk -f
NAME        FSTYPE   FSVER LABEL UUID                                 FSAVAIL FSUSE% MOUNTPOINTS
sda
nvme0n1
├─nvme0n1p1 vfat     FAT32       43A6-0FD0                             496.9M     3% /boot/efi
└─nvme0n1p2 ext4     1.0         158c794e-fea3-4653-89d8-9e6a89c0c955  332.3G    24% /
```

When you are looking to sth like `nvme0n1`, you are looking to the kernel interface of
the physical storage hardware.

> Block devices work through an I/O scheduler in the kernel that optimizes read and
> write operations. The kernel doesn't send every single request directly to the
> hardware in order it receives them. The scheduler can reorder, batch, and merge
> requests for better performance.

Linux systems uses udev to add block devices and their partitions to `/dev/`.

## Partitioning

It is possible to create partitions on block devices. Block devices exists in a
hierarchial structure, which allows the user to split the block device and use the
splits as multiple block devices. This technique is mostly used when working with hard
drives. Systems with old BIOS boot loaders use MBR(Master Boot Record) method for
partitioning and newer systems use UEFI(Unified Extensible Firmware Interface) uses GPT
(GUID Partition Table) format.

### Editing Partition Tables

Partition tables are the metadata structures that are at the beginning of the disk that
defines how the disk is divided up. You can think of it as the table of contents of the
disk, telling "hey, bytes 0 to X is partition 1, bytes X+1 ito Y is partition 2", and so
on.

There are two popular partition table schemes we are going to talk about right now. MBR
and GPT. MBR is the old standard of partition tables. It stores the metadata in the
first 512 bytes of the disk(first sector). This only gives you space for exactly 4
primary partition tables. Because of that, people are used to create an extended
partition on MBR disks, so they could create more logical partitions afterwards. Each
entry describe where the partition starts, where it ends, and what is its type. MBR
can't access disks larger than 2TB and do not store backups of the partition table, so
users will have problem if the first sector of the disk is corrupted.

GPT is the modern replacement of MBR. Instead of cramming everything into the first 512
bytes of the disk, it uses multiple sectors and also, stores a backup/redundancy of the
table in the end of the disk. It uses UUIDs to identify partitions, that is more
reliable than MBR's simple type code. It can handle 128 partitions by default and can
handle disks beyond 2TB well.

How does the MBR and GPT connects to the BIOS and UEFI. BIOS is the old firmware
standard as you may read +1000000 times till now. When the system boots with BIOS, the
BIOS will read the first 512 bytes of the disk - the MBR - which contains not just the
partition table, but also a small bootloader program that actually boots the system.
BIOS expects MBR partitioning and knows how to work with it.

On the other hand, UEFI is the modern firmware. It can understand GPT natively. When
booting, UEFI looks for a special partition named ESP(EFI System Partition), which is
formatted in FAT32 and contain bootloader programs as regular files. UEFI read those
files and boot the system.

#### fdisk

fdisk is a dialog-driven program for creation and manipulation of partition tables.

I have played a lot with fdisk and wanted to share the commands here, but the virtual
machine I was playing with is corrupted now and reinstalled because I didn't specify
filesystem for the partitions I have created:).

> Always choose filesystem for the partitions you create.

The program is straight forward and doesn't need any further instructions.

#### gdisk

Similar to `fdisk`, but it works better with GPT.

#### parted

Another application to manipulate disk partitions. Some users prefer `parted` over
`fdisk` and `gdisk`. There is also a graphical option named `gparted`.

## Formatting

After partitioning, you should format the block devices to make them actually usable:).
I didn't format my partitions so I have fucked up a whole OS. Formatting a partition
means creating a file system on it.

Formatting a partition make them usable to store files and directories. Formatting a
file system creates a map between the name of the files and directories and the place
where the actual data are stored.

There are multiple file systems on linux:

| Format | Description                                                                                                                                                               |
| ------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| ext2   | Second extended filesystem. Developed to address shortcomings in the older Unix/Minix filesystem. No journaling. Largely replaced by ext3 and ext4.                       |
| ext3   | ext2 + journaling. Maximum file size: 2 TB. Maximum filesystem size: 16 TB.                                                                                               |
| ext4   | Current version of ext. Maximum file size: 16 TB. Maximum filesystem size: 1 EB (exabyte, 1000\*1000 TB).                                                                 |
| XFS    | Journaling filesystem, caches to RAM. Suitable for systems with uninterruptible power supplies. Maximum file and filesystem size: 8 EB.                                   |
| swap   | Used when the system needs more RAM than available; acts as extra RAM on disk.                                                                                            |
| VFAT   | FAT32, no journaling. Good for data exchange with Windows. Does not support Unix permissions or symbolic links.                                                           |
| exFAT  | Extended FAT. Newer version of FAT, mainly used for external devices (e.g., USB disks) for cross-platform compatibility.                                                  |
| btrfs  | A modern, high-performance filesystem. Maximum file and filesystem size: 16 EB. Includes built-in RAID, LVM, snapshots, fault tolerance, and on-the-fly data compression. |

You can work with mkfs and its variant(or using -t switch) to format partitions.

```bash
ls /sbin/mkfs*
/sbin/mkfs  /sbin/mkfs.bfs  /sbin/mkfs.cramfs  /sbin/mkfs.exfat  /sbin/mkfs.ext2
/sbin/mkfs.ext3  /sbin/mkfs.ext4  /sbin/mkfs.fat  /sbin/mkfs.minix  /sbin/mkfs.msdos
/sbin/mkfs.ntfs  /sbin/mkfs.vfat

mkfs -t ext4 /dev/sda1
mke2fs 1.46.2 (28-Feb-2021)
Discarding device blocks: done
Creating filesystem with 262144 4k blocks and 65536 inodes
Filesystem UUID: 63625ecd-857a-419f-a300-12395aaad89f
Superblock backups stored on blocks:
    32768, 98304, 163840, 229376

Allocating group tables: done
Writing inode tables: done
Creating journal (8192 blocks): done
Writing superblocks and filesystem accounting information: done

mkfs.exfat /dev/sda5
mkexfatfs 1.3.0
Creating... done.
Flushing... done.
File system created successfully.
```

Use `blkid` command to print out the device attributes such as UUID which is mostly used
these days for identifying block devices.

```bash
/dev/nvme0n1p2: UUID="158c794e-fea3-4653-89d8-9e6a89c0c955" BLOCK_SIZE="4096" \
  TYPE="ext4" PARTUUID="5083bde2-f74d-45e0-95ac-882b2b1ab4a2"
```

Create and enable swaps:

```bash
mkswap /dev/sda5
swapon /dev/sda5
```
