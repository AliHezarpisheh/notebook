# Create, Monitor, and Kill Processes

A process is a running instance of a program.

When you have a program sitting on the disk as an executable file, it is just static
data, instructions and data encoded in binary. The moment that you execute the program,
the operating system creates a progress, which is an active living instance of the
program. From the operating system's perspective, a process is fundamentally a resource
container and an execution context. The OS allocates a memory for the process, load the
code and data into the memory, sets up a stack for function calls and local variables,
creates a heap for dynamic memory allocation, and starts executing the instructions.

The Linux kernel maintains a PCB(Process Control Block) for each process, tracking and
storing information about it, such as the PID(Process ID), which user owns the process,
how much cpu the process is using, its current state, what files are open, what memory
it's using, its parent process, its child processes, and so on.

## background and foreground

Let's cut the vague descriptions and jump into the shell, I believe everything will make
sense there:

```bash
xeyes
^Z
[1]+  Stopped                 xeyes

jobs
[1]+  Stopped                 xeyes

fg
xeyes
^C

jobs

xclock
^Z
[1]+  Stopped                 xclock

jobs -l
[1]+ 422485 Stopped                 xclock

xeyes
^Z
[2]+  Stopped                 xeyes

jobs -l
[1]- 422485 Stopped                 xclock
[2]+ 423307 Stopped                 xeyes

fg %1
xclock
^Z
[1]+  Stopped                 xclock

jobs -l
[1]+ 422485 Stopped                 xclock
[2]- 423307 Stopped                 xeyes

bg
[1]+ xclock &

jobs -l
[1]- 422485 Running                 xclock &
[2]+ 423307 Stopped                 xeyes

bg %2
[2]+ xeyes &

xeyes &
[3] 424132

jobs -l
[1]  422485 Running                 xclock &
[2]- 423307 Running                 xeyes &
[3]+ 424132 Running                 xeyes &
```

- Using `Ctrl + z`, you stop/suspend a process.
- Using `Ctrl + c`, you terminate a process.
- `jobs -l` will show you the status of the current terminal jobs.
- `fg %1` brings the job to the foreground.
- `bg %2` sends the job to the background.
- `xeyes &` sends the new xeyes process to the background.

```bash
nohup xeyes &
[1] 430538
nohup: ignoring input and appending output to 'nohup.out'

pkill xeyes
[1]+  Terminated              nohup xeyes

xeyes &
[1] 432607

jobs -l
[1]+ 432607 Running                 xeyes &

kill -9 432607
[1]+  Killed                  xeyes

jobs -l
```

- `nohup` will ignore the `HUP`(1) signals. It lets the child processes live when the
  parent process is terminated.
- `kill -<SIGNAL> 1500` will send a signal to the process with process id 1500.
- `pkill xeyes` will kill all the processes that have `xeyes` ini t.
- `killall xeyes` will kill all the processes that their name is exactly `xeyes`.

A feature of Linux programming is the idea to send and receive signals. A signal is a
kind of interrupt, used to announce asynchronous events to a process.

There are three scenarios that could happen when a signal occurs:

- It could be ignored by the program. For example, the SIGHUP will be ignored by nohup
  processes.
- Catch it and handle it.
- Fallback to the default action. Every signal has a default action.

Checkout [LINUX Signals](https://faculty.cs.niu.edu/~hutchins/csci480/signals.htm) for
more.

## Monitoring Processes

```bash
ps  # Report a snapshot of current processes which the current terminal forked and exec.
    PID TTY          TIME CMD
 453830 pts/8    00:00:00 bash
 499530 pts/8    00:00:00 ps

ps -ef  # Shows all the processes with more data.
UID          PID    PPID  C STIME TTY          TIME CMD
root           1       0  0 Dec10 ?        00:01:28 /lib/systemd/systemd --system ...
root           2       0  0 Dec10 ?        00:00:00 [kthreadd]

ps -ef | wc -l
438

ps -ef --sort +ppid
UID          PID    PPID  C STIME TTY          TIME CMD
root           1       0  0 Dec10 ?        00:01:28 /lib/systemd/systemd --system ...

pgrep xeyes | xargs kill  # Because we use a lot of ps ... | grep ...
[1]+  Terminated              xeyes
```

### top

Display a dynamic real-time view of the system.

| Key | Functionality             |
| --- | ------------------------- |
| h   | Help.                     |
| M   | Sort by the memory usage. |
| k   | Kill process.             |
| q   | Quit top.                 |
| c   | Show the full command.    |

There are htop and btop too. You may want to use them instead.

### free

free displays the amount of free and used memory in the system.

```bash
free -h
               total        used        free      shared  buff/cache   available
Mem:            15Gi       6.8Gi       3.9Gi       930Mi       4.7Gi       7.3Gi
Swap:          2.0Gi          0B       2.0Gi
```

### uptime

uptime will tell you how long the system is running, with additional information such as
the load average of 1, 5, and 15 minutes.

```bash
uptime
 11:58:57 up 5 min,  2 users,  load average: 1.61, 1.29, 0.61
```

### watch

Executes a program periodically, showing output full screen.

```bash
watch -n 1 -b -d  "free -h"
# Watch the memory with 1 second interval, beep when it exits with non-zero code, and
# show the changes using `-d`.
```

## Terminal Multiplexers

The idea is: you open an instance of your terminal emulator, and inside of them you run
a terminal multiplexer, in which by pressing some keys you have the possibility to open
multiple shells and switch between them without the need to run another instance of your
terminal emulator.

### screen

`screen` is terminal multiplexer that is installed by default in the most distros.

```bash
screen -ls  # List the screens.

screen -r 67  # Re-attach to the screen.
```

Some switches for screen, after pressing the the `Ctrl + a`:

| Key       | Usage                                               |
| --------- | --------------------------------------------------- |
| `\`       | Kill all processes windows and terminate the screen |
| `\|`      | Split current window into two vertical focuses      |
| `Shift+S` | Split current window into two horizontal focuses    |
| `C`       | Create a window in the current focus                |
| `Tab`     | Go to the next focus                                |
| `D`       | Detach from window                                  |
| `K`       | Kill current window                                 |
| `N`       | Move to Next window                                 |
| `P`       | Move to the Previous window                         |

### tmux

OK, tmux is another level. You will have a lot of work with it so yeah, I guess when you
are rereading this section, you already know how to work with it:).
