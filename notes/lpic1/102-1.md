# Design Hard Disk Layout

## Filesystem

Like any other contemporary OS, Linux uses files and directories to operate. Unlike the
Windows operating system which uses `C:`, `D:`, ... drivers, Linux uses a huge tree
starting at `/` (root).

Linux uses File System Hierarchy Standard(a standard presented in Unix). The latest
version of the standard is from 2015.

| Directory | Description                                                                                                                             |
| --------- | --------------------------------------------------------------------------------------------------------------------------------------- |
| bin       | Essential command binaries, for example `ping` binaries are here.                                                                       |
| boot      | Static files of the bootloader.                                                                                                         |
| dev       | Device files, we already talked about it at `101-1` lesson.                                                                             |
| etc       | Host-specific system configuration. You can find nginx or dhcp config here.                                                             |
| home      | Home directory for each user. It will create a directory for each user(except root).                                                    |
| lib       | Essential shared libraries and kernel modules.                                                                                          |
| media     | Mount point for removable devices.                                                                                                      |
| mnt       | Mount point for mounting a filesystem temporarily.                                                                                      |
| opt       | Add-on application software packages. For example I could install Elasticsearch here.                                                   |
| proc      | Virtual filesystem, providing an interface to kernel and system information and processes. We already talked about it in `101-1`.       |
| root      | Home directory of root.                                                                                                                 |
| sbin      | Essential system binaries. Binaries that are mostly used by the root user and are more vital for the system.                            |
| srv       | Where static files are served. You can store these in the home directory of the user too.                                               |
| tmp       | Temporary files. Sometimes it will remove its content on each boot.                                                                     |
| usr       | Secondary hierarchy. The idea was to store some user-related utilities here, now most of the directories of root fs are symlinked here. |
| var       | Variable data. `/var/log` is important cause it is where logs are stored.                                                               |

### /bin

Currently most of the time `/bin` is symlink to `/usr/bin`.

```bash
/bin/ping 4.2.2.4
PING 4.2.2.4 (4.2.2.4) 56(84) bytes of data.
64 bytes from 4.2.2.4: icmp_seq=1 ttl=50 time=122 ms
64 bytes from 4.2.2.4: icmp_seq=2 ttl=50 time=171 ms
^C
--- 4.2.2.4 ping statistics ---
2 packets transmitted, 2 received, 0% packet loss, time 1002ms
rtt min/avg/max/mdev = 121.624/146.140/170.656/24.516 ms
which ping
/usr/bin/ping
readlink -f /bin/
/usr/bin
```

### /boot

The directory is better to be partitioned separately from other partitions. The system
should be able to detect and read this part of the file system, so no encrypting is
allowed. Also, it should work if the kernel or our OS is corrupted, when it is
partitioned separately.

## Partitions

In the Linux world, devices are defined at `/dev/`. There are different naming
conventions. NVME drives: `/dev/nvme0` and sometimes: `/dev/nvme0n1` and their
partitions are on: `/dev/nvme0n1p1-2-3-...`

> You have to partition the disks. That is to create smaller parts on the disk. OS sees
> them as standalone disks.

**BIOS systems could only have up to 4 partitions. You could create sda1, sda2, sda3 as
your primary partitions, and create the sda4 as an extended partitions, enabling sda5,
sda6, ... to be logical partitions.**

**An extended partition is just an empty box for creating logical partitions on it.**

**`/dev/sda1` is a primary partition on the first disk. `/dev/sdb5` is the first logical
partition on the second disk.**

> UEFI systems uses GPT(GUID Partition Table) and can supports 128 partitions on each
> device.

**Commands:**

- fdisk /dev/nvme0n1 -> fdisk is a dialog-driven program that can create or manipulate
  partition tables.

  ```bash
  fdisk /dev/nvme0n1p1

  Welcome to fdisk (util-linux 2.37.2).
  Changes will remain in memory only, until you decide to write them.
  Be careful before using the write command.

  This disk is currently in use - repartitioning is probably a bad idea.
  It's recommended to umount all file systems, and swapoff all swap
  partitions on this disk.

  The device contains 'vfat' signature and it will be removed by a write command.
  See fdisk(8) man page and --wipe option for more details.

  Command (m for help): p

  Disk /dev/nvme0n1p1: 512 MiB, 536870912 bytes, 1048576 sectors
  Units: sectors of 1 * 512 = 512 bytes
  Sector size (logical/physical): 512 bytes / 512 bytes
  I/O size (minimum/optimal): 512 bytes / 512 bytes
  Disklabel type: dos
  Disk identifier: 0x00000000
  ```

- parted -> A program to manipulate disk partitions. Do not understands GPT.

  ```bash
  parted
  GNU Parted 3.4
  Using /dev/nvme0n1
  Welcome to GNU Parted! Type 'help' to view a list of commands.
  (parted) help
    align-check TYPE N                       check partition N for TYPE(min|opt) ...
    help [COMMAND]                           print general help, or help on COMMAND
    mklabel,mktable LABEL-TYPE               create a new disklabel (partition table)
    mkpart PART-TYPE [FS-TYPE] START END     make a partition
    name NUMBER NAME                         name partition NUMBER as NAME
    print [devices|free|list,all|NUMBER]     display the partition table, available ...
    quit                                     exit program
    rescue START END                         rescue a lost partition near START and END
    resizepart NUMBER END                    resize partition NUMBER
    rm NUMBER                                delete partition NUMBER
    select DEVICE                            choose the device to edit
    disk_set FLAG STATE                      change the FLAG on selected device
    disk_toggle [FLAG]                       toggle the state of FLAG on selected device
    set NUMBER FLAG STATE                    change the FLAG on partition NUMBER
    toggle [NUMBER [FLAG]]                   toggle the state of FLAG on partition ...
    unit UNIT                                set the default unit to UNIT
    version                                  display the version number and ...

  (parted) print
  Model: Micron MTFDKCD512QFM-1BD1AABLA (nvme)
  Disk /dev/nvme0n1: 512GB
  Sector size (logical/physical): 512B/512B
  Partition Table: gpt
  Disk Flags:

  Number  Start   End    Size   File system  Name                  Flags
  1      1049kB  538MB  537MB  fat32        EFI System Partition  boot, esp
  2      538MB   512GB  512GB  ext4
  ```

- gparted -> GUI for parted.

## LVM

Logical volume manager. A smarter tool and way to manage disks and partitions in Linux.
In many cases, you want to resize the partitions or add them on-the-fly to the system.
LVM IS DESIGNED FOR THAT SHIT.

- PV(Physical Volume): The real disks or partitions.
- VG(Volume Groups): Collection of one or more PVs. You can combine all your physical
  volumes into a VG to have a big storage pool.
- LV(Logical Volume): Virtual partitions inside the VG. Format and mount these like
  normal disks.

Use cases:

- Resize partitions easily.
- Add new disks without downtime.
- Snapshot.
- Combine multiple disks together.

## How to Design Hard Disk Layout

Disk layout and partitions depends on the use case.

### Swap

Swap in Linux work as extended memory. The kernel will page the memory into the swap
file/partition to extend memory space.

> There are some formulas for calculating swap space. I prefer `memory size + 2/4 GB`.

Currently, Linux distributions handle swap in three different ways:

1. Debian: Swap as a partition.
2. Ubuntu: Swap as a file. -> `/swapfile`
3. Fedora: Use zram. A virtual disk on the memory which compress data.

```bash
swapon  # Where is swap?
NAME      TYPE SIZE USED PRIO
/swapfile file   2G 5.3M   -2
```

### Boot

We have talked about why we should separate `/boot` into another partition. Old Linux
system could not handle huge disks during boot btw. I will recommend giving the
partition 1GB space.

### Use case 1: Desktop

Create a partition for `/boot` and give other to `/`.

### Use case 2: Server

Create local `/boot` partition. Separate `/var/log/` for obvious reasons. `/home` can be
local or network an some people like to separate the `/usr` too(?).

### Use case 3: Network Workstation

`/boot` is still local. Most of the time `/` is local. `/home` can be mounted from a
network drive.
